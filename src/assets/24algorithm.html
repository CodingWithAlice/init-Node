<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>链表 24.反转一个单链表</title>
</head>
<script>
    // 定义一个链表
    function ListNode(val) {
        this.val = val;
        this.next = null;
    }
    // 方法一
    // 思想：用数组存储反向链表的值，然后再从链表头到尾重新赋值
    // var reverseList = function (head) {
    //     // 存储第一个节点，用于获取节点值 arr
    //     let pNode = head;
    //     let arr = [];
    //     while (pNode !== null ) {
    //         arr.unshift(pNode.val);
    //         pNode = pNode.next
    //     };
    //     // 存储第一个节点，作为结果的 head
    //     let first = head;
    //     for(let i=0; i<arr.length; i++) {
    //         head.val = arr[i];
    //         head = head.next;
    //     }
    //     return first
    // };

    // 方法二：
    // var reverseList = function (head) {
    //     // head 只有一个节点
    //     if (head === null || head.next === null) {
    //         return head
    //     }
    //     let second = head.next;

    //     // head 只有两个节点
    //     if (head.next.next === null) {
    //         second.next = head;
    //         head.next = null;
    //         return second;
    //     }
    //     let third = second.next;

    //     // 大于等于3个节点
    //     // tail 节点
    //     head.next = null;
    //     while(third !== null) {
    //         second.next = head;
    //         // 往后走
    //         head = second;
    //         second = third;
    //         third = third.next;
    //     }
    //     second.next = head;

    //     // 返回头节点
    //     return second

    // }

    // 方法二简写版本
    var reverseList = function (head) {
        let prev = null;
        let current = head;
        while (current != null) {
            // 在更改引用之前，还需要另一个指针来存储下一个节点
            let next = current.next;
            // 当前节点的 next 指针改为指向前一个元素
            current.next = prev;
            // 由于节点没有引用其上一个节点，事先存储其前一个元素
            prev = current;

            // 往后走到下一个节点
            current = next;
        }
        // 此时，由于 current 已经因为 while 循环走到了下一个 null 节点，所以返回 prev
        return prev
    }
    // 伪造入参
    l1 = new ListNode(1);
    l11 = new ListNode(2);
    l12 = new ListNode(3);
    l13 = new ListNode(4);
    l14 = new ListNode(5);
    l1.next = l11;
    l11.next = l12;
    l12.next = l13;
    l13.next = l14;

    reverseList(l1);
</script>

<body>
    <div>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点 </div>
</body>

</html>