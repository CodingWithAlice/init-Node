<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>promise 的实现</title>
</head>

<body>
    <div>
        模拟实现Promise
    </div>
    <script src="../a.js">
        // promise 模型
        function Promise(fn) {
            let state = 'pending';
            let value = null;
            const callbacks = [];

            this.then = function (onFulfilled, onRejected) {
                return new Promise((resolve, reject) => {
                    handle({
                        onFulfilled,
                        onRejected,
                        resolve,
                        reject
                    })
                })
            }

            function handle(callback) {
                if (state === 'pending') {
                    callbacks.push(callback)
                    return;
                }

                const cb = state === 'fulfilled' ? callback.onFulfilled : callback.onRejected;
                const next = state === 'fulfilled' ? callback.resolve : callback.reject;

                if (!cb) {
                    next(value)
                    return;
                }
                try {
                    const ret = cb(value)
                    next(ret)
                } catch (e) {
                    callback.reject(e);
                }
            }

            function resolve(newValue) {
                const fn = () => {
                    if (state !== 'pending') return

                    if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
                        const { then } = newValue
                        if (typeof then === 'function') {
                            // newValue 为新产生的 Promise,此时resolve为上个 promise 的resolve
                            //相当于调用了新产生 Promise 的then方法，注入了上个 promise 的resolve 为其回调
                            then.call(newValue, resolve, reject)
                            return
                        }
                    }
                    state = 'fulfilled';
                    value = newValue
                    handelCb()
                }

                setTimeout(fn, 0)
            }
            function reject(error) {

                const fn = () => {
                    if (state !== 'pending') return

                    if (error && (typeof error === 'object' || typeof error === 'function')) {
                        const { then } = error
                        if (typeof then === 'function') {
                            then.call(error, resolve, reject)
                            return
                        }
                    }
                    state = 'rejected';
                    value = error
                    handelCb()
                }
                setTimeout(fn, 0)
            }
            function handelCb() {
                while (callbacks.length) {
                    const fn = callbacks.shift();
                    handle(fn);
                };
            }
            fn(resolve, reject)
        }

    </script>
    <script>
        /**
         * 明确 Promise 的几个基本信息：
         * 1、状态凝固 默认pending/resolved/rejected，改变一次后无法再变更
         * 2、传入的执行器有两个函数参数 resolve,reject，调用这两个函数触发状态变更
         * 3、执行器是同步执行的
         * 4、then 微任务执行，两个函数入参 onResolved,onRejected - catch语法糖，resolve抛出的值/reject抛出的错误原因是两个函数的参数
         * 5、then 返回的就是Promise，可以链式调用
         * 6、finally 不论返回什么值，只要改变了状态就执行
         * 7、Promise.resolve()\Promise.reject() 可以直接返回状态凝固的Promise
         * 8、Promise.all()/Promise.race()
         * */
        let Status = {
            resolve: 'fulfilled',
            reject: 'rejected',
            pending: 'pending'
        }
        function MyPromise(executor) {
            let self = this;
            self.status = Status.pending;
            self.value = null;
            self.reason = null;
            self.resolvedCallbacks = [];
            self.rejectedCallbacks = [];

            const resolve = function (value) {
                if (self.status === Status.pending) {
                    self.status = Status.resolve;
                    self.value = value;
                    self.resolvedCallbacks.forEach(it => it(self.value));
                }
            }
            const reject = function (reason) {
                if (self.status === Status.pending) {
                    self.status = Status.reject;
                    self.reason = reason;
                    self.rejectedCallbacks.forEach(it => it(self.reason));
                }
            }

            try {
                executor(resolve, reject)
            } catch (e) {
                reject(e)
            }
        }

        // 5
        MyPromise.prototype.then = function (onResolved, onRejected) {
            // this在实例化的时候指向实例本身
            const { value, reason, status, resolvedCallbacks, rejectedCallbacks } = this;

            // 兼容 then 的两个参数都是函数
            onResolved = typeof onResolved === 'function' ? onResolved : value => value;
            onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason; };

            // 链式调用
            const promise2 = new MyPromise((resolve, reject) => {
                // Promise 可以绑定多个 then 方法 
                // -> 状态已改变的promise调用then-立即执行
                // -> 状态未改变的promise调用then-异步执行 - 通过setTimeout来模拟异步调用
                const resolveFake = () => {
                    try {
                        const res = onResolved(value);
                        resolve(res);
                    } catch (reason) {
                        reject(reason)
                    }
                }
                const rejectFake = () => {
                    try {
                        const res = onRejected(reason);
                        resolve(res);
                    } catch (reason) {
                        reject(reason)
                    }
                }
                switch (status) {
                    case Status.resolve:
                        setTimeout(resolveFake, 0);
                        break;
                    case Status.reject:
                        setTimeout(rejectFake, 0);
                        break;
                    case Status.pending:
                        resolvedCallbacks.push(() => setTimeout(resolveFake, 0));
                        rejectedCallbacks.push(() => setTimeout(rejectFake, 0));
                        break;
                }
            })
            return promise2
        }

        // 4
        MyPromise.prototype.catch = function (onRejected) {
            return this.then(null, onRejected);
        }

        // 6
        MyPromise.prototype.finally = function (callback) {
            return this.then(value => {
                callback();
                return value;
            }, reason => {
                callback();
                throw reason;
            });
        }

        // 7
        MyPromise.prototype.resolve = function (value) {
            return new MyPromise((resolve) => resolve(value))
        }
        MyPromise.prototype.reject = function (reason) {
            return new MyPromise((resolve, reject) => reject(reason))
        }

        // 8
        MyPromise.prototype.all = function (arr) {
            return new MyPromise((resolve, reject) => {
                let result = [];
                let index = 0;
                for (let i = 0; i < arr.length; i++) {
                    MyPromise.resolve(arr[i]).then(data => {
                        result[i] = data;
                        if (++index === arr.length) {
                            resolve(result);
                        }
                    }, err => {
                        reject(err);
                        return;
                    });
                }
            });
        }

        MyPromise.race = function (arr) {
            return new Promise((resolve, reject) => {
                for (let i = 0; i < arr.length; i++) {
                    MyPromise.resolve(arr[i]).then(resolve, reject);
                }
            });
        }


    </script>
</body>

</html>