<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>函数柯里化/去柯里化</title>
</head>

<body>
    <!-- 柯里化：参数复用 -->
    <script>
        // 第一版
        var curry = function (fn) {
            // args 获取第一个方法内的全部参数
            var args = [].slice.call(arguments, 1);
            return function () {
                // 将后面方法里的全部参数和args进行合并
                var newArgs = args.concat([].slice.call(arguments));
                // 把合并后的参数通过apply作为fn的参数并执行
                return fn.apply(this, newArgs);
            };
        };
        // 第二版 - 支持多参数传递
        var processCurry = function(fn, args) {
            let _this = this; // 保留 this 上下文
            let len = fn.length; // JS函数的length属性 length 是函数对象的一个属性值，指该函数有多少个必须要传入的参数，那些已定义了 默认值的参数不算在内 ，比如function（xx = 0）的length是0。
            let _args = args || [];

            return function() {
                let args =  _args.concat([].slice.apply(arguments));
                // 如果参数小于最初的 length ，则继续递归调用 - 收集参数
                if (args.length < len) {
                    return processCurry.call(_this, fn, args)
                }
                // 参数收集完毕，则执行 fn
                return fn.apply(this, args);
            }
        }

        // 测试用例
        let add = (a,b) => a + b;

        var addCurry = curry(add, 1, 2);
        addCurry() // 3
        //或者
        var addCurry = curry(add, 1);
        addCurry(2) // 3
        //或者
        var addCurry = curry(add);
        addCurry(1, 2) // 3

        // 方法二测试用例
        let multiple = (a, b, c) => a * b * c;
        let processMultiple = processCurry(multiple);
        let res = processMultiple(2)(3)(4);

        let processAdd = processCurry(add);
        let addRes = processAdd(1)(2);

    </script>
    <!-- 去柯里化 -->
    <!-- <script>
        // 利用 for 循环，将 Array 的原生方法 去柯里化
        for (let i = 0, fn, ary = ['push', 'shift', 'forEach']; fn = ary[i];) {
            Array[fn] = Array.prototype[fn].uncurrying1();
        }


        // 去柯里化 - 方法一
        Function.prototype.uncurrying1 = function () {
            let self = this;
            return function () {
                let obj = Array.prototype.shift.call(arguments);
                return self.apply(obj, arguments);
            }
        }
        // 去柯里化 - 方法二
        Function.prototype.uncurrying2 = function () {
            let self = this;
            return function () {
                return Function.prototype.call.apply(self, arguments);
            }
        }


        // 测试用例 - 类数组
        let example = {
            length: 3,
            0: a,
            1: b,
            2: c,
        };

        Array.push(example, 4);
        console.log('example', example);

        let shiftRes = Array.shift(example);
        console.log('shiftRes=', shiftRes);
        console.log('example', example);

        Array.forEach(example, (element, index) => {
            console.log('element=', element, '----', index);
        });
    </script> -->
</body>

</html>